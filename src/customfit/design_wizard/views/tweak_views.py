import json
import logging

import reversion
from django.forms.models import model_to_dict
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404, render
from django.urls import reverse
from django.views.generic.edit import UpdateView

from customfit.garment_parameters.models import IndividualGarmentParameters

from .garment_registry import model_to_view
from .helpers import _ErrorCheckerMixin, _get_featured_image_url

logger = logging.getLogger(__name__)


def get_view_for_igp(view_name):

    def view(request, *args, **kwargs):

        pk = kwargs["pk"]
        igp = get_object_or_404(IndividualGarmentParameters, pk=pk)

        inner_view = model_to_view(igp, view_name)

        return inner_view(request, *args, **kwargs)

    return view


#
# Views for tweaking design choices
# -----------------------------------------------------------------------------


class _TweakGarmentViewBase(_ErrorCheckerMixin):
    """
    This view allows a user to create a new version of an IGP based on an
    existing IGP, so that they can tweak their pattern inputs before proceeding
    with the pattern creation process.

    The actual IGP creation URL is in the save() method of the associated form.
    The versioning is handled by the reversion app.

    This view is restricted to logged-in users in design_wizard/urls.py.
    """

    # Subclasses need to implement
    #
    # * form_class or get_form_class() or get_form()
    # * model
    # * get_tweak_fields()
    # * get_success_url()

    def _get_igp_dict(self):
        instance = self.get_object()

        try:
            # See if we have earlier versions. If so, return data
            # from the first.
            first_version = reversion.models.Version.objects.get_for_object(
                instance
            ).earliest("revision__id")
            igp_dict = first_version.field_dict
        except reversion.models.Version.DoesNotExist:
            # This IGP is the first version of the object, so its data
            # should be used to restore original values.
            igp_dict = model_to_dict(instance)
        return igp_dict

    def _get_restore_data(self):
        """
        Gets data from the earliest version of this IGP and returns as a dict
        (of field names & values), for use by the restore-original-values
        function of the form.
        """
        instance = self.get_object()
        igp_dict = self._get_igp_dict()

        # Make sure we return these in the user's units, since we may be
        # filling them into fields that are unit-aware.
        if self.request.user.profile.display_imperial:
            conversion = 1.0
        else:
            conversion = 2.54

        return_dict = {}

        tweak_fields = self.get_tweak_fields()

        for field in tweak_fields:
            # Some of these fields are optional, so their value may be None.
            if getattr(instance, field):
                # Need to add the id_ so that dict keys will have the same form
                # as input field IDs as generated by crispy forms.
                return_dict["id_" + field] = igp_dict[field] * conversion
            else:
                return_dict["id_" + field] = None

        return return_dict

    def get_success_url(self):
        url = reverse("design_wizard:summary", args=(self.kwargs["pk"],))
        return url

    def _check_consistency(self, request):
        igp = self.get_object()
        self._check_igp_consistency_base(request, igp)
        super(_TweakGarmentViewBase, self)._check_consistency(request)

    def get_spec_source(self):
        igp = self.get_object()
        spec_source = igp.get_spec_source()
        return spec_source

    def get_no_changes_url(self):
        return reverse("design_wizard:summary", kwargs={"igp_id": self.get_object().id})

    def get_context_data(self, **kwargs):
        context = super(_TweakGarmentViewBase, self).get_context_data(**kwargs)

        display_imperial = self.request.user.profile.display_imperial
        context["display_imperial"] = display_imperial

        if display_imperial:
            context["units"] = "inches"
        else:
            context["units"] = "cm"

        restore_dict = self._get_restore_data()
        context["restore_data"] = json.dumps(restore_dict)
        context["featured_image_url"] = _get_featured_image_url(igp=self.get_object())

        context["no_changes_url"] = self.get_no_changes_url()

        return context

    def get_form_kwargs(self):
        kwargs = super(_TweakGarmentViewBase, self).get_form_kwargs()
        kwargs["user"] = self.request.user
        return kwargs

    def form_valid(self, form):
        self.object = form.save()

        try:
            self.object.clean()
        except IndividualGarmentParameters.IncompatibleDesignInputs:
            context = self.get_context_data()
            context["form"] = form
            return render(self.request, self.template_name, context)

        # Tear down everything already made from this IGP, or the tweaking may have no effect. (If the
        # user has already been to the approve page, for example, then we've made an (unapproved) pattern
        # that we need to flush out.) Note that ErrorCheckerMixin should
        # prevent us from getting to this point if the IGP is part of an approved pattern.
        # Hence, any schematics, pieces, or patterns made from this IGP can be safely deleted

        # We need to explicitly call delete() of each model, or specific pieces/piece-schematics won't
        # get deleted.
        from customfit.patterns.models import IndividualPattern
        from customfit.pieces.models import PatternPieces
        from customfit.schematics.models import ConstructionSchematic

        # NOte that we can use IndividualPattern here, as there is no tweaking graded patterns
        for pattern in IndividualPattern.objects.filter(
            pieces__schematic__individual_garment_parameters=self.object
        ).all():
            assert not pattern.approved
            pattern.delete()

        for pattern_pieces in PatternPieces.objects.filter(
            schematic__individual_garment_parameters=self.object
        ).all():
            pattern_pieces.delete()

        for construction_schematic in ConstructionSchematic.objects.filter(
            individual_garment_parameters=self.object
        ).all():
            construction_schematic.delete()

        return HttpResponseRedirect(self.get_success_url())


class BaseTweakGarmentView(_TweakGarmentViewBase, UpdateView):

    def get_design(self):
        igp = self.get_object()
        spec_source = igp.get_spec_source()
        # Should be a PatternSpec
        design_origin = spec_source.design_origin
        design_origin = design_origin if design_origin else self.get_myo_design()
        return design_origin


tweak_garment_view = get_view_for_igp("tweak_patternspec_view")


# Views for tweaking an IGP from a redo
###########################################################################################


class BaseRedoTweakView(_TweakGarmentViewBase, UpdateView):

    # TODO: do we need separate templates for each garment-type?
    template_name = "design_wizard/tweak_redo.html"

    def get_context_data(self, **kwargs):
        context = super(BaseRedoTweakView, self).get_context_data(**kwargs)
        igp = self.get_object()
        context["design_name"] = igp.redo.pattern.name

        # Overwrite value from _TweakGarmentViewBase
        context["no_changes_url"] = self.get_no_change_url()

        return context

    def get_success_url(self):
        url = reverse("design_wizard:redo_approve", args=(self.kwargs["pk"],))
        return url

    def get_no_change_url(self):
        return reverse(
            "design_wizard:redo_approve", kwargs={"igp_id": self.get_object().id}
        )


tweak_redo_view = get_view_for_igp("tweak_redo_view")
